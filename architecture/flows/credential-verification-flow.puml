@startuml Credential-Verification-Flow
!theme plain
skinparam sequenceMessageAlign center

title Credential Verification Flow - Checking VC Validity (Phase 3)

actor "User" as user
participant "Credential Detail\nScreen" as detail_screen
participant "Verification\nService" as verify
participant "Signature\nVerifier" as sig_verifier
participant "Expiry\nChecker" as expiry
participant "Status\nChecker" as status_checker
participant "DID\nResolver" as did_resolver
participant "Key Manager" as key_manager

participant "Universal\nResolver API" as resolver_api
participant "Status List\nAPI" as status_api

database "SQLite\nDatabase" as db

== Step 1: User Views Credential (STORY-039) ==

user -> detail_screen: Opens credential
activate detail_screen

detail_screen -> db: Load credential by ID
activate db
db --> detail_screen: Credential {\n  raw: "eyJhbGci...",\n  issuer: "did:web:uni.edu",\n  subject: "did:jwk:...",\n  type: "UniversityDegree"\n}
deactivate db

detail_screen --> user: Shows credential card\n(loading verification status...)

== Step 2: Start Verification (STORY-036) ==

detail_screen -> verify: verifyCredential(credential)
activate verify

note right of verify
  **Verification Layers**:
  1. Signature (cryptographic)
  2. Expiration (date)
  3. Revocation status (online)
  4. Issuer trusted (optional)
end note

== Layer 1: Signature Verification ==

verify -> sig_verifier: verifySignature(vcJwt)
activate sig_verifier

sig_verifier -> sig_verifier: Decode JWT header
note right
  Header: {
    "alg": "EdDSA",
    "kid": "did:web:uni.edu#key-1"
  }
end note

sig_verifier -> sig_verifier: Extract issuer DID:\n"did:web:uni.edu"

sig_verifier -> did_resolver: resolveDID("did:web:uni.edu")
activate did_resolver

== Step 3: Resolve Issuer DID ==

did_resolver -> resolver_api: GET https://uni.edu/.well-known/did.json
activate resolver_api
resolver_api --> did_resolver: DID Document {\n  "@context": "...",\n  "id": "did:web:uni.edu",\n  "verificationMethod": [{\n    "id": "did:web:uni.edu#key-1",\n    "type": "Ed25519VerificationKey2020",\n    "controller": "did:web:uni.edu",\n    "publicKeyMultibase": "z6Mk..."\n  }],\n  "authentication": [...]\n}
deactivate resolver_api

did_resolver --> sig_verifier: DID Document
deactivate did_resolver

== Step 4: Verify Cryptographic Signature ==

sig_verifier -> sig_verifier: Extract public key from\nverificationMethod[0]

sig_verifier -> key_manager: verifySignature(\n  data: JWT payload,\n  signature: JWT signature,\n  publicKey: "z6Mk..."\n)
activate key_manager

key_manager -> key_manager: Ed25519.verify(\n  message,\n  signature,\n  publicKey\n)

alt Signature valid
    key_manager --> sig_verifier: Valid ‚úÖ
    sig_verifier --> verify: Signature verified ‚úÖ
else Signature invalid
    key_manager --> sig_verifier: Invalid ‚ùå
    sig_verifier --> verify: Signature failed ‚ùå
    verify --> detail_screen: Verification failed:\nInvalid signature
    detail_screen --> user: Shows ‚ùå Invalid badge
    deactivate verify
    deactivate sig_verifier
    deactivate key_manager
    deactivate detail_screen
end
deactivate key_manager
deactivate sig_verifier

== Layer 2: Expiration Check ==

verify -> expiry: checkExpiration(credential)
activate expiry

expiry -> expiry: Extract dates:\nissuanceDate: "2024-01-01T00:00:00Z"\nexpirationDate: "2029-01-01T00:00:00Z"

expiry -> expiry: Get current date:\n2024-10-20T10:00:00Z

expiry -> expiry: Compare:\ncurrent < expirationDate?

alt Not expired
    expiry --> verify: Valid ‚úÖ (4+ years remaining)
else Expired
    expiry --> verify: Expired ‚è∞
    verify --> detail_screen: Verification failed:\nCredential expired
    detail_screen --> user: Shows ‚è∞ Expired badge
    deactivate verify
    deactivate expiry
    deactivate detail_screen
end
deactivate expiry

== Layer 3: Revocation Status Check ==

verify -> status_checker: checkRevocation(credential)
activate status_checker

status_checker -> status_checker: Extract credentialStatus:\n{\n  "id": "https://uni.edu/status/1#0",\n  "type": "StatusList2021Entry",\n  "statusPurpose": "revocation",\n  "statusListIndex": "0",\n  "statusListCredential":\n    "https://uni.edu/status/1"\n}

alt Has credentialStatus
    status_checker -> status_api: GET https://uni.edu/status/1
    activate status_api
    
    note right
      **Status List VC**: Special VC containing
      a compressed bitstring:
      - Bit 0 = credential index 0
      - Bit 1 = credential index 1
      - etc.
      
      If bit = 1 ‚Üí revoked
      If bit = 0 ‚Üí valid
    end note
    
    status_api --> status_checker: Status List VC {\n  credentialSubject: {\n    type: "StatusList2021",\n    encodedList: "H4sIAAAAA..." (gzip+base64)\n  }\n}
    deactivate status_api
    
    status_checker -> status_checker: Decompress encodedList
    status_checker -> status_checker: Check bit at index 0
    
    alt Bit = 0 (not revoked)
        status_checker --> verify: Not revoked ‚úÖ
    else Bit = 1 (revoked)
        status_checker --> verify: Revoked ‚ö†Ô∏è
        verify --> detail_screen: Verification failed:\nCredential revoked
        detail_screen --> user: Shows ‚ö†Ô∏è Revoked badge
        deactivate verify
        deactivate status_checker
        deactivate detail_screen
    end
else No credentialStatus
    status_checker --> verify: No status (assume valid) ‚úÖ
end
deactivate status_checker

== Step 5: All Checks Passed ==

verify -> verify: Compile result:\n{\n  verified: true,\n  checks: {\n    signature: ‚úÖ,\n    expiration: ‚úÖ,\n    revocation: ‚úÖ\n  },\n  message: "Valid credential"\n}

verify --> detail_screen: Verification result {\n  verified: true,\n  status: "valid"\n}
deactivate verify

== Step 6: Display Result ==

detail_screen -> detail_screen: Update UI with result

detail_screen --> user: Shows:\n‚úÖ Verified badge (green)\n"This credential is valid"\nChecked: signature, expiration, status

deactivate detail_screen

== Verification Badge States ==

note over user, detail_screen
  **Badge States in UI**:
  
  ‚úÖ **Valid** (Green)
  - All checks passed
  - Signature valid
  - Not expired
  - Not revoked
  
  ‚è∞ **Expired** (Orange)
  - Signature valid
  - But expired
  - Cannot be used
  
  ‚ö†Ô∏è **Revoked** (Red)
  - Signature valid
  - But revoked by issuer
  - Cannot be trusted
  
  ‚ùå **Invalid** (Red)
  - Signature verification failed
  - Tampered or corrupted
  - Do not trust
  
  ‚ö° **Pending** (Gray)
  - Verification in progress
  - Checking status...
  
  üìµ **Offline** (Gray)
  - Cannot check status (no internet)
  - Signature verified
  - Status unknown
end note

== Caching Strategy ==

note over verify, status_api
  **Verification Caching**:
  
  1. **Signature**: Cache DID documents (1 hour)
     - Avoid repeated DID resolution
     - Faster verification
  
  2. **Status**: Cache status lists (5 minutes)
     - Reduce API calls
     - Balance freshness vs performance
  
  3. **Result**: Cache verification result (1 minute)
     - Don't re-verify on every screen view
     - Refresh if credential changes
  
  **Refresh Triggers**:
  - Pull-to-refresh
  - App comes to foreground
  - Manual "Re-verify" button
  - Cache expiration
end note

@enduml
